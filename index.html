<!DOCTYPE html>
<html>
<head>
<title>state.resolve()</title>
<style>

body {
    font-family: Monaco, monospace;
    background: #fff;
    color: #000;
    max-width: 1600px;
    width: 95%;
    margin: 20px auto;
    font-size: 18px;
    line-height: 1.2;
    letter-spacing: -0.2px;
    position: relative;
}

.left-side pre {
    line-height: 1.2;
}

.left-side pre > span + span {
    margin-top: 0;
}

.left-side pre > span:empty {
    margin: 2px 0;
}

.left-side .section-header {
    margin: 15px 0 3px 0;
    font-family: Monaco, monospace;
}

.left-side span[tabindex] {
    margin: 0;
}

.left-side pre > span {
    margin: 0;
}

.left-side pre > span[data-fn] {
    margin-bottom: 0;
}

.left-side pre > span + .section-header {
    margin-top: 4px;
}

/* Tighter spacing for SCHEDULER STATUS items */
.left-side pre > span[data-fn="check_window"],
.left-side pre > span[data-fn="next_window"],
.left-side pre > span[data-fn="toggle_auto"] {
    margin: 0 !important;
    padding: 0 !important;
    line-height: 1.0 !important;
    display: block !important;
}

/* Ensure auto_invoke has consistent alignment */
.left-side pre > span[data-fn="toggle_auto"] {
    white-space: pre !important;
    font-family: Monaco, monospace !important;
}

/* Even tighter spacing between SCHEDULER STATUS items */
.left-side pre > .section-header + span[data-fn="check_window"] {
    margin-top: -5px !important;
}

.left-side pre > span[data-fn="check_window"] + span[data-fn="next_window"],
.left-side pre > span[data-fn="next_window"] + span[data-fn="toggle_auto"] {
    margin-top: -8px !important;
}

/* Small gap between export(), edit(), and view() */
.left-side pre > span[tabindex="31"],
.left-side pre > span[tabindex="32"],
.left-side pre > span[tabindex="33"] {
    margin-bottom: 4px !important;
}

.main-interactions-group {
    display: flex;
    flex-direction: column;
    gap: 15px;
    text-align: right;
    position: absolute;
    right: 240px;
    top: 195px;
}

/* Single column layout */

.main-interactions {
    display: flex;
    flex-direction: column;
    gap: 0;
    text-align: right;
    line-height: 1.2;
    margin-right: 20px;
    font-size: 18px;
}

/* Main action buttons */
.main-interactions > span[data-fn] {
    margin-bottom: 8px;
}

/* Section headers */
.main-interactions .section-header {
    margin-top: 20px;
    margin-bottom: 10px;
    letter-spacing: 0.5px;
    font-family: Monaco, monospace;
}

/* Command items */
.main-interactions > span {
    margin-bottom: 8px;
}

/* Command output lines */
.main-interactions > span + span:not([data-fn]):not(.section-header) {
    margin-bottom: 10px;
}

/* Command spacing */
.main-interactions > span[tabindex] {
    margin-bottom: 6px;
}

.main-interactions .selectable {
    white-space: nowrap;
    letter-spacing: 0px;
}

pre > span + span {
    margin-top: 0;
}

pre > span:first-child {
    margin-top: 0;
}

pre > span:empty {
    margin: 1px 0;
}

pre > span.selectable {
    margin: 0;
}

pre > span.section-header {
    margin: 15px 0 3px 0;
    letter-spacing: 0.8px;
    font-size: 18px;
    font-family: Monaco, monospace;
}
[tabindex]:focus {
    outline: none;
    background: #fff;
    color: #000;
}
.blog-btn {
    font-family: Monaco, monospace;
    font-size: 18px;
    padding: 4px 12px;
    cursor: pointer;
    transition: background 0.1s ease;
    position: relative;
    border-radius: 7px;
}

.blog-btn:hover {
    background: #f0f0f0;
}

/* Wallet dropdown styling */
.wallet-btn {
    font-family: Monaco, monospace;
    font-size: 18px;
    padding: 4px 12px;
    cursor: pointer;
    transition: background 0.1s ease;
    position: relative;
    border-radius: 7px;
}

.wallet-btn:hover {
    background: #f0f0f0;
}

.wallet-menu {
    position: absolute;
    top: 45px;
    right: 0;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    display: none;
    font-size: 17px;
    font-family: 'DejaVu Sans Mono', monospace;
    min-width: 300px;
    z-index: 100;
    overflow: hidden;
}

.wallet-menu > div {
    display: block;
    padding: 18px 24px;
    color: #000;
    cursor: pointer;
    letter-spacing: 0;
    transition: background 0.1s ease;
    white-space: nowrap;
}

.wallet-menu > div:hover {
    background: #f8f8f8;
}

.wallet-menu > div:not(:last-child) {
    border-bottom: 1px solid #f0f0f0;
}

.wallet-menu > div:active {
    background: #f0f0f0;
}

.balance-display {
    font-family: Monaco, monospace;
    font-size: 12px;
    color: #666;
    margin-top: 3px;
    letter-spacing: 0.2px;
    display: none;
}

.selectable {
    cursor: pointer;
    padding: 2px 3px;
    margin: 1px 0;
    display: inline-block;
    font-family: Monaco, monospace;
    white-space: pre;
    font-size: 18px;
}

.selectable[tabindex] {
    display: inline-block;
    text-align: left;
    font-family: Monaco, monospace;
    letter-spacing: 0;
    font-size: 18px;
}

/* Blog section styling */
.blog-section {
    margin-top: 35px;
    padding-top: 25px;
    border-top: 1px solid #eee;
    max-width: 600px;
    text-align: left;
}

.blog-section .selectable {
    padding: 4px 8px;
    margin: 8px 0;
    transition: all 0.2s ease;
    display: block;
    white-space: normal;
    width: 100%;
}

.blog-section .selectable:hover {
    background: #f5f5f5;
}

.blog-section .section-header {
    margin-bottom: 12px;
    letter-spacing: 0.5px;
    font-size: 18px;
    font-family: Monaco, monospace;
}

/* Hover effect for all interactive buttons */
.selectable[data-fn="draw"]:hover,
.selectable[data-fn="burn"]:hover,
.selectable[data-fn="mint"]:hover,
.selectable[data-fn="replay"]:hover,
.selectable[data-fn="recurse"]:hover,
.selectable[data-fn="sacrifice"]:hover {
    background: #f0f0f0;
    padding: 2px 8px;
    transition: background 0.1s ease;
    border-radius: 7px;
}

.selectable[data-fn="fossil_1"]:hover,
.selectable[data-fn="fossil_2"]:hover,
.selectable[tabindex="31"]:hover,
.selectable[tabindex="32"]:hover,
.selectable[tabindex="33"]:hover,
.selectable[tabindex="361"]:hover,
.selectable[tabindex="364"]:hover,
.selectable[tabindex="367"]:hover,
.selectable[tabindex="370"]:hover {
    background: #f0f0f0;
    padding: 4px 12px;
    transition: background 0.1s ease;
    border-radius: 7px;
}

.selectable:focus::before {
    content: '>';
    margin-right: 3px;
}
.selectable:focus::after {
    content: '<';
    margin-left: 3px;
}
nav {
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
}
.nav-right {
    margin-left: auto;
    display: flex;
    align-items: flex-start;
    margin-right: 40px;
    position: absolute;
    right: 0;
    top: 0;
}
.timestamp {
    font-size: 17px;
    text-align: left;
    line-height: 1.2;
    margin-right: auto;
    letter-spacing: -0.2px;
}
.lunar-info {
    margin-top: 2px;
    color: #666;
    font-size: 16px;
    letter-spacing: -0.3px;
    line-height: 1.1;
}
.lunar-info span {
    display: block;
}
.nav-right a {
    margin-left: 15px;
    color: #000;
    text-decoration: none;
}
.nav-left {
    display: flex;
    gap: 20px;
    margin-left: 40px;
    margin-top: 15px;
}
.nav-left a {
    color: #000;
    text-decoration: none;
}
pre {
    margin: 0 auto;
    font-family: Monaco, monospace;
    padding: 0 30px;
    max-width: 1800px;
    font-size: 18px;
}
pre > span {
    display: block;
}
pre > span[tabindex] {
    margin: 0;
}
.title {
    text-align: center;
    font-size: 23px;
    margin: 0 auto 5px auto;
    letter-spacing: 1.2px;
    font-family: Monaco, monospace;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: auto;
    top: 10px;
}

        .title-logo {
            width: 190px;
            height: 190px;
            display: block;
            margin: 0 auto -10px auto;
            object-fit: contain;
            background: transparent;
            border: none;
        }
a { color: #000; }
</style>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
</head>
<body>
<nav>
<div class="nav-left">
<div class="timestamp">
<span id="utc-time-str">UTC 2025-01-01 00:00:00</span>
<span id="utc-time">fetching...</span>
<div class="lunar-info">
<span id="lunar-phase">EPOCH: fetching data...</span>
<span id="void-state">CONSENSUS: fetching data...</span>
</div>
</div>
</div>
<div class="nav-right" style="margin-right: 40px; display: flex; align-items: center;">
<span class="blog-btn" onclick="location.href='pori-whitepaper.html'" style="cursor: pointer; line-height: 0.9; display: inline-block; margin-right: 20px;" tabindex="4">blog</span>
<span class="wallet-btn" onclick="showWalletMenu()" style="cursor: pointer;" tabindex="5">wallet</span>
<div class="wallet-menu">
    <div onclick="connectETH()">ETH (MetaMask)</div>
    <div onclick="connectBSV()">BSV (ElectrumSV)</div>
</div>
<div class="balance-display">0 ETH</div>
</div>

<!-- Web3 -->
<script>
let provider = null;
let signer = null;
let dmapContract = null;
let vaultContract = null;

// Fill in your deployed contract addresses here or fetch from a config
const DMAP_ADDRESS = '<Your_DMAP_Address>';
const VAULT_ADDRESS = '<Your_Vault_Address>';

function initContracts() {
    if (!signer) {
        console.error('Cannot initialize contracts: signer not available');
        return;
    }
    console.log('Initializing contracts with signer:', signer);
    dmapContract = new ethers.Contract(
        DMAP_ADDRESS,
        ["event SignalRegistered(bytes32 indexed hash)", "function registerSignal(bytes32) external"],
        signer
    );
    vaultContract = new ethers.Contract(
        VAULT_ADDRESS,
        ["function registerAndLock(bytes32) external payable", "function claim(bytes32) external"],
        signer
    );
    console.log('Contracts initialized');
}

// Event handlers for wallet events
function handleAccountsChanged(accounts) {
    console.log('Accounts changed:', accounts);
    const walletBtn = document.querySelector('.wallet-btn');
    const balanceDisplay = document.querySelector('.balance-display');
    
    if (accounts.length > 0) {
        walletBtn.textContent = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
        // Update balance for new account
        updateBalance(accounts[0]);
    } else {
        walletBtn.textContent = 'wallet';
        balanceDisplay.style.display = 'none';
        provider = null;
        signer = null;
        dmapContract = null;
        vaultContract = null;
    }
}

function handleChainChanged(chainId) {
    console.log('Chain changed to:', chainId);
    // Reload page to reset state
    window.location.reload();
}

async function updateBalance(address) {
    if (!provider) return;
    
    try {
        const balance = await provider.getBalance(address);
        const balanceInEth = ethers.utils.formatEther(balance);
        const balanceDisplay = document.querySelector('.balance-display');
        balanceDisplay.textContent = `${parseFloat(balanceInEth).toFixed(4)} ETH`;
        balanceDisplay.style.display = 'block';
    } catch (error) {
        console.error('Error updating balance:', error);
    }
}
// ------------------
// RCCP Contract Actions
// ------------------

async function draw() {
    // Example: prompt for JAM data, compress and register
    const raw = prompt('Enter JAM JSON:');
    if (!raw) return;
    const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(raw));
    const ethAmt = prompt('Amount of ETH to lock (e.g., 0.01):');
    const tx = await vaultContract.registerAndLock(hash, { value: ethers.utils.parseEther(ethAmt) });
    console.log('registerAndLock tx:', tx.hash);
    await tx.wait();
    console.log('Signal registered');
}

async function burn() {
    // Claim ETH for a given hash
    const hash = prompt('Enter hash to claim:');
    if (!hash) return;
    const tx = await vaultContract.claim(hash);
    console.log('claim tx:', tx.hash);
    await tx.wait();
    console.log('Vault claimed');
}

async function mint() {
    console.log('mint() not implemented');
}

// ------------------

function showWalletMenu() {
    const menu = document.querySelector('.wallet-menu');
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

async function connectETH() {
    console.log('connectETH called');
    showWalletMenu();
    try {
        if (!window.ethereum) {
            alert('MetaMask is not installed!');
            return;
        }
        console.log('Ethereum object found');
        provider = new ethers.providers.Web3Provider(window.ethereum);
        
        console.log('Requesting accounts...');
        await provider.send('eth_requestAccounts', []);
        
        signer = provider.getSigner();
        console.log('Signer obtained:', signer);
        
        const address = await signer.getAddress();
        console.log('Wallet address:', address);
        
        // Update wallet button text
        document.querySelector('.wallet-btn').textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
        
        // Get and display balance
        const balance = await provider.getBalance(address);
        const balanceInEth = ethers.utils.formatEther(balance);
        const balanceDisplay = document.querySelector('.balance-display');
        balanceDisplay.textContent = `${parseFloat(balanceInEth).toFixed(4)} ETH`;
        balanceDisplay.style.display = 'block';
        console.log('Balance:', balanceInEth, 'ETH');
        
        // Initialize contracts after wallet is connected
        initContracts();
        
        // Listen for account changes
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);
        
    } catch (error) {
        console.error('Error connecting to MetaMask:', error);
        if (error.code === 4001) {
            console.log('User rejected connection');
        }
    }
}

function connectBSV() {
    showWalletMenu();
    alert('ElectrumSV connection functionality is not implemented yet.');
}

function updateTimestamp() {
    // Current UTC time
    const now = new Date();
    const unixTime = Math.floor(now.getTime() / 1000);
    document.getElementById('utc-time').textContent = unixTime;
    document.getElementById('utc-time-str').textContent = 'UTC ' + now.toISOString().replace('T', ' ').slice(0, -5);

    // Lunar phase calculation
    const phase = getLunarPhase(now);
    document.getElementById('lunar-phase').textContent = `EPOCH: ${phase}`;

    // Consensus window
    const consensusWindow = getVoidOfCourse(now);
    document.getElementById('void-state').textContent = `CONSENSUS: ${consensusWindow}`;

    // Update scheduler status based on window
    const windowOpen = consensusWindow === 'active';
    const schedulerWindowElements = document.querySelectorAll('[data-fn="check_window"]');
    schedulerWindowElements.forEach(el => {
        if (el.textContent.startsWith('window_open:')) {
            el.textContent = `window_open:           ${windowOpen ? 'true' : ' false'}`;
        }
    });
    
    // Calculate time to next window
    if (!windowOpen && consensusWindow.includes('next')) {
        const match = consensusWindow.match(/\[(\d{2}):(\d{2})\]/);
        if (match) {
            const nextHour = parseInt(match[1]);
            const nextMinute = parseInt(match[2]);
            const nextTime = new Date(now);
            nextTime.setUTCHours(nextHour, nextMinute, 0, 0);
            
            if (nextTime <= now) {
                nextTime.setUTCDate(nextTime.getUTCDate() + 1);
            }
            
            const secondsUntil = Math.floor((nextTime - now) / 1000);
            const minutes = Math.floor(secondsUntil / 60);
            const seconds = secondsUntil % 60;
            const timeDisplay = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            const windowNextElements = document.querySelectorAll('[data-fn="next_window"]');
            windowNextElements.forEach(el => {
                if (el.textContent.startsWith('window_next:')) {
                    el.textContent = `window_next:           ${timeDisplay}`;
                }
            });
        }
    }
}

function getLunarPhase(date) {
    // Synodic month calculation
    const synodicMonth = 29.530588853; // days
    // Reference: Full moon on July 24, 2025
    // To find the new moon, we go back ~14.765 days (half a synodic month)
    const referenceFull = new Date('2025-07-24T00:00:00Z');
    const referenceNew = new Date(referenceFull.getTime() - (14.765294426 * 24 * 60 * 60 * 1000));
    
    const daysSinceNew = (date - referenceNew) / (1000 * 60 * 60 * 24);
    const cyclesSince = daysSinceNew / synodicMonth;
    const phaseProgress = cyclesSince - Math.floor(cyclesSince);
    const percentage = Math.round(phaseProgress * 100);
    
    let phaseName;
    // Correct astronomical phase boundaries:
    // New Moon: 0% illumination (phase progress ~0.0)
    // First Quarter: 50% illumination (phase progress ~0.25)
    // Full Moon: 100% illumination (phase progress ~0.5)
    // Last Quarter: 50% illumination (phase progress ~0.75)
    if (phaseProgress < 0.0625) phaseName = 'new moon';
    else if (phaseProgress < 0.1875) phaseName = 'waxing crescent';
    else if (phaseProgress < 0.3125) phaseName = 'first quarter';
    else if (phaseProgress < 0.4375) phaseName = 'waxing gibbous';
    else if (phaseProgress < 0.5625) phaseName = 'full moon';
    else if (phaseProgress < 0.6875) phaseName = 'waning gibbous';
    else if (phaseProgress < 0.8125) phaseName = 'last quarter';
    else if (phaseProgress < 0.9375) phaseName = 'waning crescent';
    else phaseName = 'new moon';
    
    // Calculate illumination percentage based on phase progress
    // This represents the actual visible illumination of the moon
    let illumination;
    if (phaseProgress <= 0.5) {
        // Waxing phase (new to full)
        illumination = Math.round(phaseProgress * 200);
    } else {
        // Waning phase (full to new)
        illumination = Math.round((1 - phaseProgress) * 200);
    }
    
    // Don't override with fixed values - show exact percentage
    return `${phaseName} [${illumination}%]`;
}

async function handleAccountsChanged(accounts) {
    const walletBtn = document.getElementById('walletBtn');
    if (accounts.length > 0) {
        const address = accounts[0];
        walletBtn.textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
        walletBtn.classList.add('connected');
    } else {
        walletBtn.textContent = 'wallet';
        walletBtn.classList.remove('connected');
        provider = null;
        signer = null;
    }
}

function handleChainChanged() {
    // Reload the page on chain change
    window.location.reload();
}

function getVoidOfCourse(date) {
    // Consensus window times in UTC
    const consensusTimes = [
        { hour: 3, minute: 33 },
        { hour: 8, minute: 1 },
        { hour: 13, minute: 21 },
        { hour: 20, minute: 8 },
        { hour: 21, minute: 1 }
    ];
    
    const currentHour = date.getUTCHours();
    const currentMinute = date.getUTCMinutes();
    const currentTimeInMinutes = currentHour * 60 + currentMinute;
    
    // Find the next consensus window
    let nextWindow = null;
    let minTimeDiff = Infinity;
    
    for (const time of consensusTimes) {
        const windowTimeInMinutes = time.hour * 60 + time.minute;
        let timeDiff = windowTimeInMinutes - currentTimeInMinutes;
        
        // If the window is earlier in the day, add 24 hours
        if (timeDiff < 0) {
            timeDiff += 24 * 60;
        }
        
        if (timeDiff < minTimeDiff && timeDiff > 0) {
            minTimeDiff = timeDiff;
            nextWindow = time;
        }
    }
    
    // Check if we're currently in a window (within 1 minute)
    for (const time of consensusTimes) {
        if (currentHour === time.hour && Math.abs(currentMinute - time.minute) <= 1) {
            return 'active';
        }
    }
    
    if (nextWindow) {
        return `next [${nextWindow.hour.toString().padStart(2, '0')}:${nextWindow.minute.toString().padStart(2, '0')}]`;
    }
    
    return 'next [03:33]'; // fallback
}

// Run updateTimestamp immediately when script loads
updateTimestamp();

// Initialize timestamp updates
setInterval(updateTimestamp, 1000);

// Add event listener to close wallet menu when clicking outside
document.addEventListener('DOMContentLoaded', function() {
    // Auto-blur focused elements after 4 seconds
    let blurTimeout;
    document.addEventListener('focus', function(event) {
        if (event.target.hasAttribute('tabindex')) {
            // Clear any existing timeout
            if (blurTimeout) {
                clearTimeout(blurTimeout);
            }
            // Set new timeout to blur after 2 seconds
            blurTimeout = setTimeout(function() {
                event.target.blur();
            }, 2000);
        }
    }, true);
    
    document.addEventListener('click', function(event) {
        const walletBtn = document.querySelector('.wallet-btn');
        const walletMenu = document.querySelector('.wallet-menu');
        const isClickInsideWallet = walletBtn.contains(event.target) || walletMenu.contains(event.target);
        
        if (!isClickInsideWallet && walletMenu.style.display === 'block') {
            walletMenu.style.display = 'none';
        }
    });
    
    // Add click handler for auto_invoke toggle
    const autoInvokeElement = document.querySelector('[data-fn="toggle_auto"]');
    if (autoInvokeElement) {
        let isFocused = false;
        
        autoInvokeElement.addEventListener('click', function() {
            if (!isFocused) {
                // First click: just focus (which shows < > via CSS)
                this.focus();
                isFocused = true;
            } else {
                // Second click: toggle the state
                const currentText = this.textContent;
                if (currentText.includes('enabled')) {
                    this.textContent = 'auto_invoke:           disabled';
                } else {
                    this.textContent = 'auto_invoke:           enabled';
                }
            }
        });
        
        // Reset focus state when element loses focus
        autoInvokeElement.addEventListener('blur', function() {
            isFocused = false;
        });
    }
});
</script>
</div>
</nav>
</div>

<div class="title">
    <img src="logo.png" alt="Logo" class="title-logo">
    <span style="font-family: Monaco, monospace;">state.resolve()</span>
</div>

<div class="main-content" style="display: flex; margin-top: 230px;">
<div style="width: 700px;" class="left-side">
<pre style="line-height: 1.2; font-size: 18px;">
<span class="section-header">JAM COMPRESSION</span>
<span class="selectable" tabindex="9" data-fn="get_tx_hash">tx_hash:          0x7c92...3f4a</span>
<span class="selectable" tabindex="10" data-fn="get_anchor">anchor:           n/a</span>
<span class="selectable" tabindex="11" data-fn="get_path">path:             ETH > USDC > DAI</span>
<span class="selectable" tabindex="12" data-fn="get_intent">intent:           semantic_proverb</span>
<span class="selectable" tabindex="12" data-fn="get_stake_weight">weight:           0.00</span>


<span class="section-header">SCHEDULER STATUS</span>
<span data-fn="check_window">window_open:           fetching...</span>
<span data-fn="next_window">window_next:           fetching...</span>
<span class="selectable" tabindex="24" data-fn="toggle_auto">auto_invoke:           enabled</span>

<span class="section-header">LOGS / IPFS MEMORY</span>
<span class="selectable" tabindex="25" data-fn="fossil_1">  - { id: fossil_001, fn: emit_aether, ts: 2025-06-13T12:11Z }</span>
<span class="selectable" tabindex="26" data-fn="fossil_2">  - { id: fossil_002, fn: cleanse_karma, ts: 2025-06-14T02:03Z }</span>

<span class="selectable" tabindex="31">export()</span>
<span class="selectable" tabindex="32">edit()</span>
<span class="selectable" tabindex="33">view()</span>

<span class="section-header">LIVE NODE / P2P STATUS</span>
peers:            0 connected
ipfs_hash:        QmNUzWDZboZo...tigQ1rL5
dmap:             0xb2Ea...e919


</pre>
</div>
<div>
<div class="main-interactions" style="width: 550px; text-align: right; margin-left: 350px;">
<span class="section-header" style="letter-spacing: 2px;">EMISSION INTERFACE</span>
<br>
<span class="selectable" tabindex="1" data-fn="draw" style="letter-spacing: 1.5px;">draw()</span>
<br>
<span class="selectable" tabindex="2" data-fn="burn" style="letter-spacing: 1.5px;">burn()</span>
<br>
<span class="selectable" tabindex="3" data-fn="mint" style="letter-spacing: 1.5px;">mint()</span>

<span class="section-header">CORE VERBS</span>
<span class="selectable" tabindex="361">[ attestYield()     ]</span>
<span data-fn="attest_output">> captured: fetching...</span>

<span class="selectable" tabindex="364">[ harvestYield()    ]</span>
<span data-fn="harvest_output">> harvested: fetching...</span>

<span class="selectable" tabindex="367">[ withdrawYield()   ]</span>
<span data-fn="withdraw_output">> withdrawn: fetching...</span>

<span class="selectable" tabindex="370">[ authorizeTrapper() ]</span>
<span data-fn="authorize_output">> honeypot: fetching...</span>

<br><br>
<span class="section-header">TOKEN FUNCTIONS</span>
<span class="selectable" tabindex="17" data-fn="replay">replay()</span>
<br>
<span class="selectable" tabindex="18" data-fn="recurse">recurse()</span>
<br>
<span class="selectable" tabindex="19" data-fn="sacrifice">sacrifice()</span>
</div>
</div>
</div>
</body>
</html>
